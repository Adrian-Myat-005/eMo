################################################################################
#                                                                              #
#                      THE SADSMILE ECOSYSTEM: USER MANUAL                     #
#                            "From Scratch to Pro"                             #
#                                                                              #
#                                Version 1.0                                   #
#                                January 2026                                  #
#                                                                              #
################################################################################

TABLE OF CONTENTS
=================
1.  INTRODUCTION
2.  GETTING STARTED
3.  THE SADSMILE SHELL
4.  THE SHADOW SYSTEM (Clone & Learn)
5.  THE THINKING VIRUS (AI Companion)
6.  HAPPYCRY LANGUAGE: THE BASICS
7.  HAPPYCRY LANGUAGE: ADVANCED TOPICS
8.  PROJECT TUTORIALS
9.  SYSTEM ARCHITECTURE
10. TROUBLESHOOTING & REFERENCE

################################################################################
# 1. INTRODUCTION
################################################################################

Welcome to the SadSmile Ecosystem.

This isn't just a shell; it's a "Conversational Automation Environment."
Traditional development involves switching between a terminal, a code editor,
stack overflow, and documentation. SadSmile collapses these into one flow.

PHILOSOPHY
----------
1.  **Local First**: Your code runs on your machine.
2.  **Human Readable**: Code should look like English, not hieroglyphics.
3.  **AI Integrated**: The "Brain" (Tvrus) is a first-class citizen, not a plugin.
4.  **Learning by Cloning**: The "Shadow" system allows you to instantly adopt
    patterns from the open-source world.

COMPONENTS
----------
*   **SadSmile (ss)**: The shell that orchestrates everything.
*   **HappyCry (hpy)**: The compiled language that powers your automation.
*   **Tvrus (AI)**: The intelligence layer that writes and edits code for you.
*   **Shadow**: The bridge to the external world (GitHub, etc.).

################################################################################
# 2. GETTING STARTED
################################################################################

PREREQUISITES
-------------
*   Linux or macOS
*   Rust Toolchain (cargo, rustc)
*   Git
*   Python 3 (for Interop Gates)

INSTALLATION
------------
(If you are reading this, you are likely already inside the system.)
To build the entire suite from source:

    $ cargo build --release

This produces binaries in `target/release/`.

RUNNING THE SHELL
-----------------
To enter the SadSmile environment:

    $ ./target/debug/sadsmile

The prompt will change to `ss$`. You are now in control.

################################################################################
# 3. THE SADSMILE SHELL
################################################################################

The shell behaves like a standard BASH shell but with superpowers.

STANDARD COMMANDS
-----------------
*   `cd <dir>`: Change directory.
*   `ls`: List files.
*   `exit`: Leave the shell.
*   It supports pipes `|` and redirections `>` just like bash.

INTEGRATED TOOLS
----------------
When you type `happy`, `shadow`, or `tvrus`, the shell prioritizes its own
internal tools over system binaries. This ensures version consistency.

################################################################################
# 4. THE SHADOW SYSTEM (Clone & Learn)
################################################################################

Don't reinvent the wheel. Steal it (legally).

CONCEPT
-------
The Shadow System analyzes external repositories, understands their structure,
and creates a "Blueprint" (`.shw` file). You can then clone this blueprint
into a HappyCry project scaffold.

COMMANDS
--------

1.  **LEARN**
    Analyzes a remote repository.
    
    ss$ shadow learn --url https://github.com/username/repo

    Output: A file named `blueprint.shw`.
    This file contains metadata, detected languages, and key patterns.

2.  **CLONE**
    Converts a blueprint into HappyCry code.

    ss$ shadow clone blueprint.shw

    Output: A `main.hpy` file customized for the project type.
    - If it was a Node.js repo -> Generates a Web Server scaffold.
    - If it was a Rust repo -> Generates an Async Task scaffold.

################################################################################
# 5. THE THINKING VIRUS (AI Companion)
################################################################################

The ThinkingVirus (`tvrus`) is your AI pair programmer. It doesn't just chat;
it touches files.

SETUP
-----
(Configuration is handled in `~/.config/happy/virus.toml` or similar.
 Ensure you have an API key set if required by the backend.)

COMMANDS
--------

1.  **VIBE (Generate)**
    Create something from nothing.
    
    ss$ tvrus vibe "Create a tool that organizes my downloads folder"

    Result: Tvrus will output a complete `.hpy` script to stdout.
    Tip: Redirect it to a file:
    ss$ tvrus vibe "..." > organizer.hpy

2.  **EDIT (Modify)**
    Change existing code using natural language.
    
    ss$ tvrus edit main.hpy "Add error handling to the database connection"

    Result: Tvrus reads `main.hpy`, applies the changes, and outputs the result.

################################################################################
# 6. HAPPYCRY LANGUAGE: THE BASICS
################################################################################

HappyCry files end in `.hpy`.
They are compiled to Rust, then to native machine code.

HELLO WORLD
-----------
    say "Hello, World!"

VARIABLES
---------
    # Create
    create variable count with value 0
    
    # Update (Legacy syntax)
    set count to 5

MATH
----
    math count add 1
    # Supports: add (Currently optimized for accumulation)

CONTROL FLOW
------------
    # If / Else
    if count is 5 do
        say "High Five!"
    else
        say "Keep counting"
    end

    # Loops
    loop 10 times do
        say "Running..."
    end

FUNCTIONS
---------
    func greet do
        say "Greetings!"
    end

    call greet

################################################################################
# 7. HAPPYCRY LANGUAGE: ADVANCED TOPICS
################################################################################

This is where HappyCry shines: Full-stack automation.

A. WEB SERVER (HappyWeb)
------------------------
Create a high-performance HTTP server in seconds.

    server new port 8080

    page "/" do
        title "Home"
        add header "Welcome"
        say "This is generated at runtime."
    end

    page "/status" do
        say "All systems operational."
    end

    serve "Server Started"

B. DATABASE (HappyBase)
-----------------------
Built-in SQLite support.

    db open "data.db"
    db run "CREATE TABLE IF NOT EXISTS users (name TEXT)"
    db insert into "users" values "('Alice')"

C. ASYNC & CONCURRENCY
----------------------
Run tasks in the background without blocking the main thread.

    async task background_job do
        loop 100 times do
            say "Working..."
        end
    end

    # Wait for it to finish (optional)
    await background_job

D. SWARM NETWORKING (P2P)
-------------------------
Connect multiple HappyCry nodes.

    swarm join "my-cluster"
    swarm broadcast "I am alive"

E. AI INTEGRATION (Brain)
-------------------------
Embed AI decisions in your logic.
    
    create variable user_input with value "I hate this!"
    create variable sentiment with value 0
    
    # This sends a request to Tvrus at runtime
    set sentiment to ai think "Is this positive or negative?" about user_input

F. GATES (Interop)
------------------
Run Python or System commands seamlessly.
    
    # Execute Python code and ignore result
    gate to python execute "import math; print(math.pi)"

################################################################################
# 8. PROJECT TUTORIALS
################################################################################

TUTORIAL 1: THE SMART LOG ANALYZER
----------------------------------
Goal: Watch a file, check for errors using AI, and alert via P2P.

1.  Create `analyzer.hpy`:
    
    server new port 9000
    db open "logs.db"
    
    async task monitor do
        loop 10 times do
            # Simulate getting a log line
            create variable log_line with value "Error: Disk Full"
            
            # Ask AI
            create variable is_bad with value ""
            set is_bad to ai think "Is this log critical?" about log_line
            
            if is_bad is "Yes" do
                swarm broadcast "CRITICAL ERROR DETECTED"
            end
        end
    end
    
    serve

2.  Build and Run:
    ss$ happy build analyzer.hpy
    ss$ ./analyzer

################################################################################
# 9. SYSTEM ARCHITECTURE (Under the Hood)
################################################################################

For those who want to know how it works.

THE COMPILER PIPELINE
---------------------
1.  **Lexer (`lexer.rs`)**:
    Converts English-like text into `Tokens` (e.g., `Token::Server`, `Token::Do`).
    It handles string literals, numbers, and identifiers.

2.  **Parser (`parser.rs`)**:
    Converts Tokens into an Abstract Syntax Tree (AST).
    It handles nested blocks (If, Loop, Async) and expression precedence.

3.  **Codegen (`codegen_fixed.rs`)**:
    Walks the AST and emits **Rust** source code.
    - `server new` -> Generates `actix_web` boilerplate.
    - `async task` -> Generates `tokio::spawn`.
    - `gate to python` -> Generates `std::process::Command("python3")`.

4.  **Builder (`main.rs`)**:
    Writes the Rust code to a temporary Cargo project, adds dependencies
    (actix-web, tokio, serde) dynamically, and runs `cargo build --release`.

################################################################################
# 10. TROUBLESHOOTING
################################################################################

Q: "Compilation Failed" with "unresolved import actix_web"
A: This happens if the builder didn't create the Cargo.toml correctly. Ensure
   you are using the latest version of `happy` which uses the Cargo build strategy.

Q: Python Gate hangs?
A: Ensure your Python code doesn't wait for input. The system runs it with `python3 -c`.

Q: "Expected 'do' after..."
A: HappyCry V2 is strict about block delimiters. Use `do` and `end`.
   Example: `if x is 1 do ... end`.

================================================================================
                                  END OF MANUAL
================================================================================
